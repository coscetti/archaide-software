from collections import namedtuple
import numpy as np

from c3d.algorithm.drawings import DrawingError
from c3d.algorithm.sample import get_outline2_length
from c3d.datamodel import Profile2, Outline2
from . import gen_cuts


def normal(plane):
    result = np.asanyarray([plane.A, plane.B, plane.C])
    return result / np.linalg.norm(result)


def make_vec(val, length):
    val = np.asanyarray(val)
    if val.ndim == 0:
        val = np.full((length,), val)
    return val


def solve_square(a, b, c, n):
    a = make_vec(a, n)
    b = make_vec(b, n)
    c = make_vec(c, n)
    delta = b * b - 4 * a * c
    valid = delta >= 0
    result = np.zeros((len(valid), 2))
    result[~valid, :] = np.nan
    delta_root = np.sqrt(delta[valid])
    result[valid, 0] = (-b[valid] + delta_root) / (2 * a[valid])
    result[valid, 1] = (-b[valid] - delta_root) / (2 * a[valid])
    return result


def normalize(vec):
    return vec / np.linalg.norm(vec)


PlaneAxes = namedtuple('PlaneAxes', ['side', 'up', 'origin'])


def plane_axes(plane):
    """
    Generate a 2D coordinate system based on a given fracture plane.
    """
    assert isinstance(plane, gen_cuts.Plane3D)
    p_normal = normal(plane)
    # Make sure Z is not fixed
    assert not (p_normal[0] == 0 and p_normal[1] == 0)

    # Get a sideways vector on the plane
    up = np.array([0, 0, 1])
    side_on_plane = normalize(np.cross(up, p_normal))

    # And an up vector on the plane
    up_on_plane = normalize(np.cross(side_on_plane, p_normal))
    if up_on_plane[2] < 0:
        up_on_plane = -up_on_plane

    # Take Ax + By + Cz + D = 0
    # Substitute Z = 0 and obtain Ax + By = -D
    # We get one of two solutions:
    # x = - (D + By) / A
    # y = - (D + Ax) / B
    # We want the more numerically stable solution, so we'll pick the first
    # if abs(A) > abs(B), otherwise we'll take the second. In these cases we
    # we'll set the other coordinate (x or y) to zero.
    if abs(plane.A) > abs(plane.B):
        x = -plane.D / plane.A
        y = 0
        z = 0
    else:
        x = 0
        y = -plane.D / plane.B
        z = 0

    return PlaneAxes(side=side_on_plane, up=up_on_plane,
                     origin=np.array([x, y, z]))


def plane_coordinates(pts3d, plane_ax):
    """
    Given 3D points generated by the intersection of the revolved model with
    the specified plane, project these back to (X, Y) points.
    :param pts3d: Nx3 numpy.ndarray of points
    :param plane_ax: The axes (PlaneAxes) of the plane
    :return: Nx2 numpy.ndarray of 2D points
    """
    assert isinstance(plane_ax, PlaneAxes)
    # X is how much we go sideways
    x = np.dot(pts3d - plane_ax.origin, plane_ax.side)
    # Y is how much we go up with the Z axis
    y = np.dot(pts3d - plane_ax.origin, plane_ax.up)
    return np.vstack((x[i], y[i]) for i in range(len(x)))


def cut_outlines(pts2d, plane):
    assert isinstance(plane, gen_cuts.Plane3D)
    pts2d = np.asanyarray(pts2d)
    n = len(pts2d)

    # X becomes radius, Y becomes Z
    r = pts2d[:, 0]
    assert np.all((r >= 0) | (r <= 0))
    r = np.abs(r)
    z = pts2d[:, 1]

    # The result points are on the plane, so
    # Ax + By + Cz + D = 0
    # Define T = Cz + D
    # Ax + By = -T
    T = (plane.C * z + plane.D)

    if abs(plane.A) > abs(plane.B):
        # x = - (T + By) / A
        # And also
        # x^2 + y^2 = r
        # Sub and we get
        # (T + By)^2 / A^2 + y^2 = r
        a = (plane.B ** 2) / (plane.A ** 2) + 1
        b = (2 * T * plane.B) / (plane.A ** 2)
        c = (T ** 2) / (plane.A ** 2) - r * r
        y = solve_square(a, b, c, n)
        x = - (T.reshape(n, 1) + plane.B * y) / plane.A
    else:
        # y = - (T + Ax) / B
        # And also
        # x^2 + y^2 = r
        # Sub and we get
        # x^2 + (T + Ax)^2 / B^2 = r
        a = 1 + (plane.A ** 2) / (plane.B ** 2)
        b = (2 * plane.A * T) / (plane.B ** 2)
        c = (T ** 2) / (plane.B ** 2) - r * r
        x = solve_square(a, b, c, n)
        y = - (T.reshape(n, 1) + plane.A * x) / plane.B

    result1 = np.zeros((n, 3))
    result2 = np.zeros((n, 3))

    result1[:, 0] = x[:, 0]
    result2[:, 0] = x[:, 1]

    result1[:, 1] = y[:, 0]
    result2[:, 1] = y[:, 1]

    result1[:, 2] = z
    result2[:, 2] = z

    return result1, result2


def does_x_align_need_flip(pts2d_src, pts2d_to_fix):
    # Check for NaN values before moving on to the next step, as it will fail if
    # all input X values are NaN
    if np.all(np.isnan(pts2d_to_fix[:, 0])):
        return False
    min_index = np.nanargmin(pts2d_to_fix[:, 0])
    max_index = np.nanargmax(pts2d_to_fix[:, 0])
    return pts2d_src[min_index, 0] > pts2d_src[max_index, 0]


def x_align(pts2d_src, pts2d_to_fix):
    result = np.asarray(pts2d_to_fix)
    if does_x_align_need_flip(pts2d_src, pts2d_to_fix):
        result[:, 0] *= -1
    return result


def inside_map_subset(outline, valid_points_mask):
    assert isinstance(outline, Outline2)
    assert len(outline) == len(valid_points_mask)
    new_map = list(outline.inside_map)
    for i in range(len(new_map)):
        new_map[i] = (
            Outline2.NEITHER if not valid_points_mask[(i + 1) % len(outline)]
            else new_map[i]
        )
    return new_map


def cut_profile(profile2, plane):
    assert isinstance(profile2, Profile2)
    axes = plane_axes(plane)
    outlines = []
    for outline in profile2.outlines:
        pts2d = np.asanyarray(outline.points)
        # Cutting a cylinder with a plane, we will get two fractures
        outline3d, _ = cut_outlines(pts2d, plane)
        # Project to 2D using the plane
        outline2d = plane_coordinates(outline3d, axes)
        # Check if the fracture has reversed X and if so, fix it
        outline2d = x_align(pts2d_src=pts2d, pts2d_to_fix=outline2d)
        # Check which points are valid
        valid_mask = ~np.any(np.isnan(outline3d), axis=1)
        # Subset the inside_map to exclude segments with some invalid points
        inside_map = inside_map_subset(outline, valid_mask)
        outlines.append(
            Outline2(outline2d, inside_map)
        )
    return Profile2(outlines, simplification_area=profile2.simplification_area)


def above_line(points, line):
    above = line.A * points[:, 0] + line.B * points[:, 1] + line.C < 0
    invert = line.B > 0
    return above ^ invert


def trim_outlines(profile2, line_bot, line_top):
    assert isinstance(profile2, Profile2)
    outlines = []
    for outline in profile2.outlines:
        pts2d = np.asanyarray(outline.points)
        n = len(pts2d)
        valid_mask = np.full((n,), True)
        valid_mask &= ~above_line(pts2d, line_top)
        valid_mask &= above_line(pts2d, line_bot)
        inside_map = inside_map_subset(outline, valid_mask)
        outlines.append(
            Outline2(outline.points, inside_map)
        )
    return Profile2(outlines, simplification_area=profile2.simplification_area)


def fracture_profile(profile2, min_length, max_tries=10):
    for i in range(max_tries):
        max_radius = np.nanmax([p[0] for o in profile2.outlines for p in o.points])
        plane = gen_cuts.generate_fracture_plane(max_radius)
        fracture = cut_profile(profile2, plane)

        all_pts = np.vstack(p for o in profile2.outlines for p in o.points)
        top = np.nanmax(all_pts[:, 1])
        bottom = np.nanmin(all_pts[:, 1])
        mean_x = np.nanmean(all_pts[:, 0])
        line_bot, line_top = gen_cuts.make_y_range_lines(bottom, top,
                                                         min_size=10, mean_x=mean_x)
        ret = trim_outlines(fracture, line_bot, line_top)
        # Don't return sherds unless they have at least 20mm
        length = sum(get_outline2_length(o) for o in ret.outlines)
        if length >= min_length:
            return ret
    raise DrawingError('Could not generate fracture longer than %s' % min_length)
